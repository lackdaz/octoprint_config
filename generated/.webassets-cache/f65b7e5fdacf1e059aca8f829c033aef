V// source: plugin/octolapse/js/octolapse.profiles.rendering.js\u000a/*\u000a##################################################################################\u000a# Octolapse - A plugin for OctoPrint used for making stabilized timelapse videos.\u000a# Copyright (C) 2017  Brad Hochgesang\u000a##################################################################################\u000a# This program is free software: you can redistribute it and/or modify\u000a# it under the terms of the GNU Affero General Public License as published\u000a# by the Free Software Foundation, either version 3 of the License, or\u000a# (at your option) any later version.\u000a#\u000a# This program is distributed in the hope that it will be useful,\u000a# but WITHOUT ANY WARRANTY; without even the implied warranty of\u000a# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\u000a# GNU Affero General Public License for more details.\u000a#\u000a# You should have received a copy of the GNU Affero General Public License\u000a# along with this program.  If not, see the following:\u000a# https://github.com/FormerLurker/Octolapse/blob/master/LICENSE\u000a#\u000a# You can contact the author either through the git-hub repository, or at the\u000a# following email address: FormerLurker@pm.me\u000a##################################################################################\u000a*/\u000a$(function() {\u000a    WatermarkImage = function(filepath) {\u000a        var self = this;\u000a        // The full file path on the OctoPrint server.\u000a        self.filepath = filepath;\u000a\u000a        // Returns just the filename portion from a full filepath.\u000a        self.getFilename = function() {\u000a            // Function stolen from https://stackoverflow.com/a/25221100.\u000a            return self.filepath.split('\u005c\u005c').pop().split('/').pop();\u000a        };\u000a    };\u000a\u000a    Font = function(filepath) {\u000a        var self = this;\u000a        // The full file path on the OctoPrint server.\u000a        self.filepath = filepath;\u000a\u000a        // Returns just the filename portion from a full filepath.\u000a        self.getFilename = function() {\u000a            // Function stolen from https://stackoverflow.com/a/25221100.\u000a            return self.filepath.split('\u005c\u005c').pop().split('/').pop();\u000a        };\u000a    };\u000a\u000a    Octolapse.RenderingProfileViewModel = function (values) {\u000a        var self = this;\u000a        self.profileTypeName = ko.observable("Render")\u000a        self.guid = ko.observable(values.guid);\u000a        self.name = ko.observable(values.name);\u000a        self.description = ko.observable(values.description);\u000a        self.enabled = ko.observable(values.enabled);\u000a        self.fps_calculation_type = ko.observable(values.fps_calculation_type);\u000a        self.run_length_seconds = ko.observable(values.run_length_seconds);\u000a        self.fps = ko.observable(values.fps);\u000a        self.max_fps = ko.observable(values.max_fps);\u000a        self.min_fps = ko.observable(values.min_fps);\u000a        self.output_format = ko.observable(values.output_format);\u000a        self.sync_with_timelapse = ko.observable(values.sync_with_timelapse);\u000a        self.bitrate = ko.observable(values.bitrate);\u000a        self.post_roll_seconds = ko.observable(values.post_roll_seconds);\u000a        self.pre_roll_seconds = ko.observable(values.pre_roll_seconds);\u000a        self.output_template = ko.observable(values.output_template);\u000a        self.enable_watermark = ko.observable(values.enable_watermark);\u000a        self.selected_watermark = ko.observable(values.selected_watermark); // Absolute filepath of the selected watermark.\u000a        self.watermark_list = ko.observableArray(); // A list of WatermarkImages that are available for selection on the server.\u000a        self.overlay_text_template = ko.observable(values.overlay_text_template);\u000a        self.font_list = ko.observableArray(); // A list of Fonts that are available for selection on the server.\u000a        self.overlay_font_path = ko.observable(values.overlay_font_path);\u000a        self.overlay_font_size = ko.observable(values.overlay_font_size);\u000a        // Text position as a JSON string.\u000a        self.overlay_text_pos = ko.pureComputed({\u000a            read: function() {\u000a                var x = +self.overlay_text_pos_x();\u000a                var y = +self.overlay_text_pos_y();\u000a                // Validate x and y.\u000a                // Ensure they are integers.\u000a                if (self.overlay_text_pos_x().length == 0 || x % 1 != 0 || self.overlay_text_pos_y().length == 0 || y % 1 != 0) {\u000a                    return "";\u000a                }\u000a\u000a                return JSON.stringify([x, y]);\u000a            },\u000a            write: function(value) {\u000a                if (value === undefined) {\u000a                    return;\u000a                }\u000a                xy = JSON.parse(value);\u000a                self.overlay_text_pos_x(xy[0]);\u000a                self.overlay_text_pos_y(xy[1]);\u000a            },\u000a        });\u000a        self.overlay_text_pos_x = values.overlay_text_pos_x === undefined ? ko.observable() : ko.observable(values.overlay_text_pos_x);\u000a        self.overlay_text_pos_y = values.overlay_text_pos_y === undefined ? ko.observable() : ko.observable(values.overlay_text_pos_y);\u000a        self.overlay_text_pos(values.overlay_text_pos);\u000a        self.overlay_text_alignment = ko.observable(values.overlay_text_alignment);\u000a        self.overlay_text_valign = ko.observable(values.overlay_text_valign);\u000a        self.overlay_text_halign = ko.observable(values.overlay_text_halign);\u000a        // The overlay text colour in as a 4-element array, represented in a string. Note values vary from 0-255.\u000a        // ie. [57, 64, 32, 25]\u000a        self.overlay_text_color = ko.observable(values.overlay_text_color);\u000a        // The overlay text color formatted as a CSS value. Note RGB vary from 0-255, but A varies from 0-1.\u000a        // ie. rgba(57, 64, 32, 0.1).\u000a        self.overlay_text_color_as_css = ko.pureComputed({\u000a            read: function () {\u000a                // Convert to js.\u000a                var rgba = JSON.parse(self.overlay_text_color());\u000a                // Divide alpha by 255.\u000a                rgba[3] = rgba[3] / 255;\u000a                // Build the correct string.\u000a                return 'rgba(' + rgba.join(', ') + ')'\u000a            },\u000a            write: function (value) {\u000a                // Extract values.\u000a                var rgba = /rgba\u005c((\u005cd+),\u005cs*(\u005cd+),\u005cs*(\u005cd+),\u005cs(\u005cd*\u005c.?\u005cd+)\u005c)/.exec(value).slice(1).map(Number);\u000a                // Multiply alpha by 255 and round.\u000a                rgba[3] = Math.round(rgba[3] * 255);\u000a                // Write to variable.\u000a                self.overlay_text_color(JSON.stringify(rgba));\u000a            },\u000a        });\u000a\u000a        self.overlay_preview_image = ko.observable('');\u000a        self.overlay_preview_image_error = ko.observable('');\u000a        self.thread_count = ko.observable(values.thread_count)\u000a        self.overlay_preview_image_src = ko.computed(function() {\u000a            return 'data:image/jpeg;base64,' + self.overlay_preview_image();\u000a        });\u000a        self.overlay_preview_image_alt_text = ko.computed(function() {\u000a            if (self.overlay_preview_image_error.length == 0) {\u000a                return 'A preview of the overlay text.'\u000a            }\u000a            return 'Image could not be retrieved from server. The error returned was: ' + self.overlay_preview_image_error() + '.';\u000a        });\u000a\u000a        self.can_synchronize_format = ko.pureComputed(function() {\u000a           return ['mp4','h264'].indexOf(self.output_format()) > -1;\u000a        });\u000a\u000a        // This function is called when the Edit Profile dialog shows.\u000a        self.onShow = function() {\u000a             $('#overlay_color').minicolors({format: 'rgb', opacity: true});\u000a             self.updateWatermarkList();\u000a             self.updateFontList();\u000a             self.initWatermarkUploadButton();\u000a             self.requestOverlayPreview();\u000a\u000a        };\u000a\u000a        self.selectWatermark = function(watermark_image) {\u000a            if (watermark_image === undefined) {\u000a                self.enable_watermark(false);\u000a                self.selected_watermark("");\u000a                return;\u000a            }\u000a            self.enable_watermark(true);\u000a            self.selected_watermark(watermark_image.filepath);\u000a        };\u000a\u000a        self.deleteWatermark = function(watermarkImage, event) {\u000a            OctoPrint.postJson(OctoPrint.getBlueprintUrl('octolapse') +\u000a                'rendering/watermark/delete', {'path': watermarkImage.filepath}, {'Content-Type':'application/json'})\u000a                    .then(function(response) {\u000a                        // Deselect the watermark if we just deleted the selected watermark.\u000a                        if (self.selected_watermark() == watermarkImage.filepath) {\u000a                            self.selectWatermark();\u000a                        }\u000a                        self.updateWatermarkList();\u000a                    }, function(response) {\u000a                        // TODO: Display error message in UI.\u000a                        //console.log("Failed to delete " + watermarkImage.filepath);\u000a                        //console.log(response);\u000a                    });\u000a            event.stopPropagation();\u000a        };\u000a\u000a        // Load watermark list from server-side Octolapse directory.\u000a        self.updateWatermarkList = function() {\u000a\u000a             return OctoPrint.get(OctoPrint.getBlueprintUrl('octolapse') +\u000a                'rendering/watermark')\u000a                    .then(function(response) {\u000a                        self.watermark_list.removeAll()\u000a                        // The let format is not working in some versions of safari\u000a                        for (var index = 0; index < response['filepaths'].length;index++) {\u000a                            self.watermark_list.push(new WatermarkImage(response['filepaths'][index]));\u000a                        }\u000a                     }, function(response) {\u000a                        self.watermark_list.removeAll()\u000a                        // Hacky solution, but good enough. We shouldn't encounter this error too much anyways.\u000a                        self.watermark_list.push(new WatermarkImage("Failed to load watermarks from Octolapse data directory."));\u000a                     });\u000a        };\u000a\u000a        self.initWatermarkUploadButton = function() {\u000a             // Set up the file upload button.\u000a             var $watermarkUploadElement = $('#octolapse_watermark_path_upload');\u000a             var $progressBarContainer = $('#octolapse-upload-watermark-progress');\u000a             var $progressBar = $progressBarContainer.find('.progress-bar');\u000a\u000a             $watermarkUploadElement.fileupload({\u000a                dataType: "json",\u000a                maxNumberOfFiles: 1,\u000a                headers: OctoPrint.getRequestHeaders(),\u000a                // Need to chunk large image files or else OctoPrint/Flask will reject them.\u000a                // TODO: Octoprint limits file upload size on a per-endpoint basis.\u000a                // http://docs.octoprint.org/en/master/plugins/hooks.html#octoprint-server-http-bodysize\u000a                maxChunkSize: 100000,\u000a                progressall: function (e, data) {\u000a                    // TODO: Get a better progress bar implementation.\u000a                    var progress = parseInt(data.loaded / data.total * 100, 10);\u000a                    $progressBar.text(progress + "%");\u000a                    $progressBar.animate({'width': progress + '%'}, {'queue':false});\u000a                },\u000a                done: function(e, data) {\u000a                    $progressBar.text("Done!");\u000a                    $progressBar.animate({'width': '100%'}, {'queue':false});\u000a                    self.updateWatermarkList().then(function() {\u000a                        // Find the new watermark in the list and select it.\u000a                        var matchingWatermarks = [];\u000a                        // The lambda version was not working in safari\u000a                        for(var index=0;index<self.watermark_list();index++)\u000a                        {\u000a                            if(data.files[0] == self.watermark_list()[index].getFilename())\u000a                                matchingWatermarks.push(self.watermark_list()[index]);\u000a                        }\u000a                        //var matchingWatermarks = self.watermark_list().filter(w=>w.getFilename() == data.files[0].name);\u000a                        if (matchingWatermarks.length == 0) {\u000a                            //console.log("Error: No matching watermarks found!");\u000a                            return\u000a                        }\u000a                        if (matchingWatermarks > 1){\u000a                            //console.log("Error: More than one matching watermark found! Selecting best guess.");\u000a                        }\u000a                        self.selectWatermark(matchingWatermarks[0]);\u000a                    });\u000a                },\u000a                fail: function(e, data) {\u000a                    $progressBar.text("Failed...").addClass('failed');\u000a                    $progressBar.animate({'width': '100%'}, {'queue':false});\u000a                }\u000a             });\u000a        };\u000a\u000a        // Load font list from server-side.\u000a        self.updateFontList = function() {\u000a             return OctoPrint.get(OctoPrint.getBlueprintUrl('octolapse') + 'rendering/font')\u000a                    .then(function(response) {\u000a                        self.font_list.removeAll();\u000a                        // The let expression was not working in safari\u000a                        for (var index = 0; index< response.length; index++) {\u000a                            self.font_list.push(new Font(response[index]));\u000a                        }\u000a                     }, function(response) {\u000a                        // Failed to load any fonts.\u000a                        self.font_list.removeAll();\u000a                     });\u000a        };\u000a\u000a        // Select a specific font for the overlay.\u000a        self.selectOverlayFont = function(font) {\u000a            self.overlay_font_path(font.filepath);\u000a        };\u000a\u000a        // Request a preview of the overlay from the server.\u000a        self.requestOverlayPreview = function() {\u000a            data = {\u000a                    'overlay_text_template': self.overlay_text_template(),\u000a                    'overlay_font_path': self.overlay_font_path(),\u000a                    'overlay_font_size': self.overlay_font_size(),\u000a                    'overlay_text_pos': self.overlay_text_pos(),\u000a                    'overlay_text_alignment': self.overlay_text_alignment(),\u000a                    'overlay_text_valign': self.overlay_text_valign(),\u000a                    'overlay_text_halign': self.overlay_text_halign(),\u000a                    'overlay_text_color': self.overlay_text_color(),\u000a            };\u000a            OctoPrint.post(OctoPrint.getBlueprintUrl('octolapse') + 'rendering/previewOverlay', data)\u000a                .then(function(response, success_name, response_status) {\u000a                    // Loaded the overlay!\u000a                    self.overlay_preview_image(response.image);\u000a                    self.overlay_preview_image_error('');\u000a                },\u000a                function(response_status, error_name, stack_trace) {\u000a                    // Failed to load an overlay.\u000a                    //console.log('Failed to load overlay preview from server.')\u000a                    //console.log(stack_trace);\u000a                    self.overlay_preview_image('');\u000a                    self.overlay_preview_image_error('Error loading overlay preview: ' + error_name + '. Click to refresh.');\u000a                });\u000a        };\u000a\u000a        self.toJS = function()\u000a        {\u000a            var copy = ko.toJS(self);\u000a            delete copy.font_list;\u000a            delete copy.overlay_preview_image;\u000a            delete copy.overlay_preview_image_src;\u000a            return copy;\u000a        };\u000a    };\u000a    Octolapse.RenderingProfileValidationRules = {\u000a        rules: {\u000a            bitrate: { required: true, ffmpegBitRate: true },\u000a            output_format : {required: true},\u000a            fps_calculation_type: {required: true},\u000a            min_fps: { lessThanOrEqual: '#rendering_profile_max_fps' },\u000a            max_fps: { greaterThanOrEqual: '#rendering_profile_min_fps' },\u000a            overlay_text_valign: {required: true},\u000a            overlay_text_halign: {required: true},\u000a            overlay_text_alignment: {required: true},\u000a            output_template: {\u000a                remote: {\u000a                    url: "./plugin/octolapse/validateRenderingTemplate",\u000a                    type:"post"\u000a                }\u000a            },\u000a            overlay_text_template: {\u000a                remote: {\u000a                    url: "./plugin/octolapse/validateOverlayTextTemplate",\u000a                    type:"post"\u000a                }\u000a            },\u000a            octolapse_overlay_font_size: { required: true, integerPositive: true },\u000a            octolapse_overlay_text_pos: { required: true },\u000a        },\u000a        messages: {\u000a            name: "Please enter a name for your profile",\u000a            min_fps: { lessThanOrEqual: 'Must be less than or equal to the maximum fps.' },\u000a            max_fps: { greaterThanOrEqual: 'Must be greater than or equal to the minimum fps.' },\u000a            output_template: { octolapseRenderingTemplate: 'Either there is an invalid token in the rendering template, or the resulting file name is not valid.' },\u000a            overlay_text_template: { octolapseOverlayTextTemplate: 'Either there is an invalid token in the overlay text template, or the resulting file name is not valid.' },\u000a            octolapse_overlay_text_pos: { required: 'Position offsets must be valid integers.' },\u000a        }\u000a    };\u000a});\u000a\u000a\u000a\u000a;\u000a
p0
.