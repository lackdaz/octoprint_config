V// source: plugin/printhistory/js/jquery.flot.stack.js\u000a/* Flot plugin for stacking data sets rather than overlyaing them.\u000a\u000aCopyright (c) 2007-2014 IOLA and Ole Laursen.\u000aLicensed under the MIT license.\u000a\u000aThe plugin assumes the data is sorted on x (or y if stacking horizontally).\u000aFor line charts, it is assumed that if a line has an undefined gap (from a\u000anull point), then the line above it should have the same gap - insert zeros\u000ainstead of "null" if you want another behaviour. This also holds for the start\u000aand end of the chart. Note that stacking a mix of positive and negative values\u000ain most instances doesn't make sense (so it looks weird).\u000a\u000aTwo or more series are stacked when their "stack" attribute is set to the same\u000akey (which can be any number or string or just "true"). To specify the default\u000astack, you can set the stack option like this:\u000a\u000a	series: {\u000a		stack: null/false, true, or a key (number/string)\u000a	}\u000a\u000aYou can also specify it for a single series, like this:\u000a\u000a	$.plot( $("#placeholder"), [{\u000a		data: [ ... ],\u000a		stack: true\u000a	}])\u000a\u000aThe stacking order is determined by the order of the data series in the array\u000a(later series end up on top of the previous).\u000a\u000aInternally, the plugin modifies the datapoints in each series, adding an\u000aoffset to the y value. For line series, extra data points are inserted through\u000ainterpolation. If there's a second y value, it's also adjusted (e.g for bar\u000acharts or filled areas).\u000a\u000a*/\u000a\u000a(function ($) {\u000a    var options = {\u000a        series: { stack: null } // or number/string\u000a    };\u000a    \u000a    function init(plot) {\u000a        function findMatchingSeries(s, allseries) {\u000a            var res = null;\u000a            for (var i = 0; i < allseries.length; ++i) {\u000a                if (s == allseries[i])\u000a                    break;\u000a                \u000a                if (allseries[i].stack == s.stack)\u000a                    res = allseries[i];\u000a            }\u000a            \u000a            return res;\u000a        }\u000a        \u000a        function stackData(plot, s, datapoints) {\u000a            if (s.stack == null || s.stack === false)\u000a                return;\u000a\u000a            var other = findMatchingSeries(s, plot.getData());\u000a            if (!other)\u000a                return;\u000a\u000a            var ps = datapoints.pointsize,\u000a                points = datapoints.points,\u000a                otherps = other.datapoints.pointsize,\u000a                otherpoints = other.datapoints.points,\u000a                newpoints = [],\u000a                px, py, intery, qx, qy, bottom,\u000a                withlines = s.lines.show,\u000a                horizontal = s.bars.horizontal,\u000a                withbottom = ps > 2 && (horizontal ? datapoints.format[2].x : datapoints.format[2].y),\u000a                withsteps = withlines && s.lines.steps,\u000a                fromgap = true,\u000a                keyOffset = horizontal ? 1 : 0,\u000a                accumulateOffset = horizontal ? 0 : 1,\u000a                i = 0, j = 0, l, m;\u000a\u000a            while (true) {\u000a                if (i >= points.length)\u000a                    break;\u000a\u000a                l = newpoints.length;\u000a\u000a                if (points[i] == null) {\u000a                    // copy gaps\u000a                    for (m = 0; m < ps; ++m)\u000a                        newpoints.push(points[i + m]);\u000a                    i += ps;\u000a                }\u000a                else if (j >= otherpoints.length) {\u000a                    // for lines, we can't use the rest of the points\u000a                    if (!withlines) {\u000a                        for (m = 0; m < ps; ++m)\u000a                            newpoints.push(points[i + m]);\u000a                    }\u000a                    i += ps;\u000a                }\u000a                else if (otherpoints[j] == null) {\u000a                    // oops, got a gap\u000a                    for (m = 0; m < ps; ++m)\u000a                        newpoints.push(null);\u000a                    fromgap = true;\u000a                    j += otherps;\u000a                }\u000a                else {\u000a                    // cases where we actually got two points\u000a                    px = points[i + keyOffset];\u000a                    py = points[i + accumulateOffset];\u000a                    qx = otherpoints[j + keyOffset];\u000a                    qy = otherpoints[j + accumulateOffset];\u000a                    bottom = 0;\u000a\u000a                    if (px == qx) {\u000a                        for (m = 0; m < ps; ++m)\u000a                            newpoints.push(points[i + m]);\u000a\u000a                        newpoints[l + accumulateOffset] += qy;\u000a                        bottom = qy;\u000a                        \u000a                        i += ps;\u000a                        j += otherps;\u000a                    }\u000a                    else if (px > qx) {\u000a                        // we got past point below, might need to\u000a                        // insert interpolated extra point\u000a                        if (withlines && i > 0 && points[i - ps] != null) {\u000a                            intery = py + (points[i - ps + accumulateOffset] - py) * (qx - px) / (points[i - ps + keyOffset] - px);\u000a                            newpoints.push(qx);\u000a                            newpoints.push(intery + qy);\u000a                            for (m = 2; m < ps; ++m)\u000a                                newpoints.push(points[i + m]);\u000a                            bottom = qy; \u000a                        }\u000a\u000a                        j += otherps;\u000a                    }\u000a                    else { // px < qx\u000a                        if (fromgap && withlines) {\u000a                            // if we come from a gap, we just skip this point\u000a                            i += ps;\u000a                            continue;\u000a                        }\u000a                            \u000a                        for (m = 0; m < ps; ++m)\u000a                            newpoints.push(points[i + m]);\u000a                        \u000a                        // we might be able to interpolate a point below,\u000a                        // this can give us a better y\u000a                        if (withlines && j > 0 && otherpoints[j - otherps] != null)\u000a                            bottom = qy + (otherpoints[j - otherps + accumulateOffset] - qy) * (px - qx) / (otherpoints[j - otherps + keyOffset] - qx);\u000a\u000a                        newpoints[l + accumulateOffset] += bottom;\u000a                        \u000a                        i += ps;\u000a                    }\u000a\u000a                    fromgap = false;\u000a                    \u000a                    if (l != newpoints.length && withbottom)\u000a                        newpoints[l + 2] += bottom;\u000a                }\u000a\u000a                // maintain the line steps invariant\u000a                if (withsteps && l != newpoints.length && l > 0\u000a                    && newpoints[l] != null\u000a                    && newpoints[l] != newpoints[l - ps]\u000a                    && newpoints[l + 1] != newpoints[l - ps + 1]) {\u000a                    for (m = 0; m < ps; ++m)\u000a                        newpoints[l + ps + m] = newpoints[l + m];\u000a                    newpoints[l + 1] = newpoints[l - ps + 1];\u000a                }\u000a            }\u000a\u000a            datapoints.points = newpoints;\u000a        }\u000a        \u000a        plot.hooks.processDatapoints.push(stackData);\u000a    }\u000a    \u000a    $.plot.plugins.push({\u000a        init: init,\u000a        options: options,\u000a        name: 'stack',\u000a        version: '1.2'\u000a    });\u000a})(jQuery);\u000a\u000a;\u000a
p0
.