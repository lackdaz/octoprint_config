V// source: plugin/printhistory/js/jquery.flot.pie.js\u000a/* Flot plugin for rendering pie charts.\u000a\u000aCopyright (c) 2007-2014 IOLA and Ole Laursen.\u000aLicensed under the MIT license.\u000a\u000aThe plugin assumes that each series has a single data value, and that each\u000avalue is a positive integer or zero.  Negative numbers don't make sense for a\u000apie chart, and have unpredictable results.  The values do NOT need to be\u000apassed in as percentages; the plugin will calculate the total and per-slice\u000apercentages internally.\u000a\u000a* Created by Brian Medendorp\u000a\u000a* Updated with contributions from btburnett3, Anthony Aragues and Xavi Ivars\u000a\u000aThe plugin supports these options:\u000a\u000a	series: {\u000a		pie: {\u000a			show: true/false\u000a			radius: 0-1 for percentage of fullsize, or a specified pixel length, or 'auto'\u000a			innerRadius: 0-1 for percentage of fullsize or a specified pixel length, for creating a donut effect\u000a			startAngle: 0-2 factor of PI used for starting angle (in radians) i.e 3/2 starts at the top, 0 and 2 have the same result\u000a			tilt: 0-1 for percentage to tilt the pie, where 1 is no tilt, and 0 is completely flat (nothing will show)\u000a			offset: {\u000a				top: integer value to move the pie up or down\u000a				left: integer value to move the pie left or right, or 'auto'\u000a			},\u000a			stroke: {\u000a				color: any hexidecimal color value (other formats may or may not work, so best to stick with something like '#FFF')\u000a				width: integer pixel width of the stroke\u000a			},\u000a			label: {\u000a				show: true/false, or 'auto'\u000a				formatter:  a user-defined function that modifies the text/style of the label text\u000a				radius: 0-1 for percentage of fullsize, or a specified pixel length\u000a				background: {\u000a					color: any hexidecimal color value (other formats may or may not work, so best to stick with something like '#000')\u000a					opacity: 0-1\u000a				},\u000a				threshold: 0-1 for the percentage value at which to hide labels (if they're too small)\u000a			},\u000a			combine: {\u000a				threshold: 0-1 for the percentage value at which to combine slices (if they're too small)\u000a				color: any hexidecimal color value (other formats may or may not work, so best to stick with something like '#CCC'), if null, the plugin will automatically use the color of the first slice to be combined\u000a				label: any text value of what the combined slice should be labeled\u000a			}\u000a			highlight: {\u000a				opacity: 0-1\u000a			}\u000a		}\u000a	}\u000a\u000aMore detail and specific examples can be found in the included HTML file.\u000a\u000a*/\u000a\u000a(function($) {\u000a\u000a	// Maximum redraw attempts when fitting labels within the plot\u000a\u000a	var REDRAW_ATTEMPTS = 10;\u000a\u000a	// Factor by which to shrink the pie when fitting labels within the plot\u000a\u000a	var REDRAW_SHRINK = 0.95;\u000a\u000a	function init(plot) {\u000a\u000a		var canvas = null,\u000a			target = null,\u000a			options = null,\u000a			maxRadius = null,\u000a			centerLeft = null,\u000a			centerTop = null,\u000a			processed = false,\u000a			ctx = null;\u000a\u000a		// interactive variables\u000a\u000a		var highlights = [];\u000a\u000a		// add hook to determine if pie plugin in enabled, and then perform necessary operations\u000a\u000a		plot.hooks.processOptions.push(function(plot, options) {\u000a			if (options.series.pie.show) {\u000a\u000a				options.grid.show = false;\u000a\u000a				// set labels.show\u000a\u000a				if (options.series.pie.label.show == "auto") {\u000a					if (options.legend.show) {\u000a						options.series.pie.label.show = false;\u000a					} else {\u000a						options.series.pie.label.show = true;\u000a					}\u000a				}\u000a\u000a				// set radius\u000a\u000a				if (options.series.pie.radius == "auto") {\u000a					if (options.series.pie.label.show) {\u000a						options.series.pie.radius = 3/4;\u000a					} else {\u000a						options.series.pie.radius = 1;\u000a					}\u000a				}\u000a\u000a				// ensure sane tilt\u000a\u000a				if (options.series.pie.tilt > 1) {\u000a					options.series.pie.tilt = 1;\u000a				} else if (options.series.pie.tilt < 0) {\u000a					options.series.pie.tilt = 0;\u000a				}\u000a			}\u000a		});\u000a\u000a		plot.hooks.bindEvents.push(function(plot, eventHolder) {\u000a			var options = plot.getOptions();\u000a			if (options.series.pie.show) {\u000a				if (options.grid.hoverable) {\u000a					eventHolder.unbind("mousemove").mousemove(onMouseMove);\u000a				}\u000a				if (options.grid.clickable) {\u000a					eventHolder.unbind("click").click(onClick);\u000a				}\u000a			}\u000a		});\u000a\u000a		plot.hooks.processDatapoints.push(function(plot, series, data, datapoints) {\u000a			var options = plot.getOptions();\u000a			if (options.series.pie.show) {\u000a				processDatapoints(plot, series, data, datapoints);\u000a			}\u000a		});\u000a\u000a		plot.hooks.drawOverlay.push(function(plot, octx) {\u000a			var options = plot.getOptions();\u000a			if (options.series.pie.show) {\u000a				drawOverlay(plot, octx);\u000a			}\u000a		});\u000a\u000a		plot.hooks.draw.push(function(plot, newCtx) {\u000a			var options = plot.getOptions();\u000a			if (options.series.pie.show) {\u000a				draw(plot, newCtx);\u000a			}\u000a		});\u000a\u000a		function processDatapoints(plot, series, datapoints) {\u000a			if (!processed)	{\u000a				processed = true;\u000a				canvas = plot.getCanvas();\u000a				target = $(canvas).parent();\u000a				options = plot.getOptions();\u000a				plot.setData(combine(plot.getData()));\u000a			}\u000a		}\u000a\u000a		function combine(data) {\u000a\u000a			var total = 0,\u000a				combined = 0,\u000a				numCombined = 0,\u000a				color = options.series.pie.combine.color,\u000a				newdata = [];\u000a\u000a			// Fix up the raw data from Flot, ensuring the data is numeric\u000a\u000a			for (var i = 0; i < data.length; ++i) {\u000a\u000a				var value = data[i].data;\u000a\u000a				// If the data is an array, we'll assume that it's a standard\u000a				// Flot x-y pair, and are concerned only with the second value.\u000a\u000a				// Note how we use the original array, rather than creating a\u000a				// new one; this is more efficient and preserves any extra data\u000a				// that the user may have stored in higher indexes.\u000a\u000a				if ($.isArray(value) && value.length == 1) {\u000a    				value = value[0];\u000a				}\u000a\u000a				if ($.isArray(value)) {\u000a					// Equivalent to $.isNumeric() but compatible with jQuery < 1.7\u000a					if (!isNaN(parseFloat(value[1])) && isFinite(value[1])) {\u000a						value[1] = +value[1];\u000a					} else {\u000a						value[1] = 0;\u000a					}\u000a				} else if (!isNaN(parseFloat(value)) && isFinite(value)) {\u000a					value = [1, +value];\u000a				} else {\u000a					value = [1, 0];\u000a				}\u000a\u000a				data[i].data = [value];\u000a			}\u000a\u000a			// Sum up all the slices, so we can calculate percentages for each\u000a\u000a			for (var i = 0; i < data.length; ++i) {\u000a				total += data[i].data[0][1];\u000a			}\u000a\u000a			// Count the number of slices with percentages below the combine\u000a			// threshold; if it turns out to be just one, we won't combine.\u000a\u000a			for (var i = 0; i < data.length; ++i) {\u000a				var value = data[i].data[0][1];\u000a				if (value / total <= options.series.pie.combine.threshold) {\u000a					combined += value;\u000a					numCombined++;\u000a					if (!color) {\u000a						color = data[i].color;\u000a					}\u000a				}\u000a			}\u000a\u000a			for (var i = 0; i < data.length; ++i) {\u000a				var value = data[i].data[0][1];\u000a				if (numCombined < 2 || value / total > options.series.pie.combine.threshold) {\u000a					newdata.push(\u000a						$.extend(data[i], {     /* extend to allow keeping all other original data values\u000a						                           and using them e.g. in labelFormatter. */\u000a							data: [[1, value]],\u000a							color: data[i].color,\u000a							label: data[i].label,\u000a							angle: value * Math.PI * 2 / total,\u000a							percent: value / (total / 100)\u000a						})\u000a					);\u000a				}\u000a			}\u000a\u000a			if (numCombined > 1) {\u000a				newdata.push({\u000a					data: [[1, combined]],\u000a					color: color,\u000a					label: options.series.pie.combine.label,\u000a					angle: combined * Math.PI * 2 / total,\u000a					percent: combined / (total / 100)\u000a				});\u000a			}\u000a\u000a			return newdata;\u000a		}\u000a\u000a		function draw(plot, newCtx) {\u000a\u000a			if (!target) {\u000a				return; // if no series were passed\u000a			}\u000a\u000a			var canvasWidth = plot.getPlaceholder().width(),\u000a				canvasHeight = plot.getPlaceholder().height(),\u000a				legendWidth = target.children().filter(".legend").children().width() || 0;\u000a\u000a			ctx = newCtx;\u000a\u000a			// WARNING: HACK! REWRITE THIS CODE AS SOON AS POSSIBLE!\u000a\u000a			// When combining smaller slices into an 'other' slice, we need to\u000a			// add a new series.  Since Flot gives plugins no way to modify the\u000a			// list of series, the pie plugin uses a hack where the first call\u000a			// to processDatapoints results in a call to setData with the new\u000a			// list of series, then subsequent processDatapoints do nothing.\u000a\u000a			// The plugin-global 'processed' flag is used to control this hack;\u000a			// it starts out false, and is set to true after the first call to\u000a			// processDatapoints.\u000a\u000a			// Unfortunately this turns future setData calls into no-ops; they\u000a			// call processDatapoints, the flag is true, and nothing happens.\u000a\u000a			// To fix this we'll set the flag back to false here in draw, when\u000a			// all series have been processed, so the next sequence of calls to\u000a			// processDatapoints once again starts out with a slice-combine.\u000a			// This is really a hack; in 0.9 we need to give plugins a proper\u000a			// way to modify series before any processing begins.\u000a\u000a			processed = false;\u000a\u000a			// calculate maximum radius and center point\u000a\u000a			maxRadius =  Math.min(canvasWidth, canvasHeight / options.series.pie.tilt) / 2;\u000a			centerTop = canvasHeight / 2 + options.series.pie.offset.top;\u000a			centerLeft = canvasWidth / 2;\u000a\u000a			if (options.series.pie.offset.left == "auto") {\u000a				if (options.legend.position.match("w")) {\u000a					centerLeft += legendWidth / 2;\u000a				} else {\u000a					centerLeft -= legendWidth / 2;\u000a				}\u000a				if (centerLeft < maxRadius) {\u000a					centerLeft = maxRadius;\u000a				} else if (centerLeft > canvasWidth - maxRadius) {\u000a					centerLeft = canvasWidth - maxRadius;\u000a				}\u000a			} else {\u000a				centerLeft += options.series.pie.offset.left;\u000a			}\u000a\u000a			var slices = plot.getData(),\u000a				attempts = 0;\u000a\u000a			// Keep shrinking the pie's radius until drawPie returns true,\u000a			// indicating that all the labels fit, or we try too many times.\u000a\u000a			do {\u000a				if (attempts > 0) {\u000a					maxRadius *= REDRAW_SHRINK;\u000a				}\u000a				attempts += 1;\u000a				clear();\u000a				if (options.series.pie.tilt <= 0.8) {\u000a					drawShadow();\u000a				}\u000a			} while (!drawPie() && attempts < REDRAW_ATTEMPTS)\u000a\u000a			if (attempts >= REDRAW_ATTEMPTS) {\u000a				clear();\u000a				target.prepend("<div class='error'>Could not draw pie with labels contained inside canvas</div>");\u000a			}\u000a\u000a			if (plot.setSeries && plot.insertLegend) {\u000a				plot.setSeries(slices);\u000a				plot.insertLegend();\u000a			}\u000a\u000a			// we're actually done at this point, just defining internal functions at this point\u000a\u000a			function clear() {\u000a				ctx.clearRect(0, 0, canvasWidth, canvasHeight);\u000a				target.children().filter(".pieLabel, .pieLabelBackground").remove();\u000a			}\u000a\u000a			function drawShadow() {\u000a\u000a				var shadowLeft = options.series.pie.shadow.left;\u000a				var shadowTop = options.series.pie.shadow.top;\u000a				var edge = 10;\u000a				var alpha = options.series.pie.shadow.alpha;\u000a				var radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;\u000a\u000a				if (radius >= canvasWidth / 2 - shadowLeft || radius * options.series.pie.tilt >= canvasHeight / 2 - shadowTop || radius <= edge) {\u000a					return;	// shadow would be outside canvas, so don't draw it\u000a				}\u000a\u000a				ctx.save();\u000a				ctx.translate(shadowLeft,shadowTop);\u000a				ctx.globalAlpha = alpha;\u000a				ctx.fillStyle = "#000";\u000a\u000a				// center and rotate to starting position\u000a\u000a				ctx.translate(centerLeft,centerTop);\u000a				ctx.scale(1, options.series.pie.tilt);\u000a\u000a				//radius -= edge;\u000a\u000a				for (var i = 1; i <= edge; i++) {\u000a					ctx.beginPath();\u000a					ctx.arc(0, 0, radius, 0, Math.PI * 2, false);\u000a					ctx.fill();\u000a					radius -= i;\u000a				}\u000a\u000a				ctx.restore();\u000a			}\u000a\u000a			function drawPie() {\u000a\u000a				var startAngle = Math.PI * options.series.pie.startAngle;\u000a				var radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;\u000a\u000a				// center and rotate to starting position\u000a\u000a				ctx.save();\u000a				ctx.translate(centerLeft,centerTop);\u000a				ctx.scale(1, options.series.pie.tilt);\u000a				//ctx.rotate(startAngle); // start at top; -- This doesn't work properly in Opera\u000a\u000a				// draw slices\u000a\u000a				ctx.save();\u000a				var currentAngle = startAngle;\u000a				for (var i = 0; i < slices.length; ++i) {\u000a					slices[i].startAngle = currentAngle;\u000a					drawSlice(slices[i].angle, slices[i].color, true);\u000a				}\u000a				ctx.restore();\u000a\u000a				// draw slice outlines\u000a\u000a				if (options.series.pie.stroke.width > 0) {\u000a					ctx.save();\u000a					ctx.lineWidth = options.series.pie.stroke.width;\u000a					currentAngle = startAngle;\u000a					for (var i = 0; i < slices.length; ++i) {\u000a						drawSlice(slices[i].angle, options.series.pie.stroke.color, false);\u000a					}\u000a					ctx.restore();\u000a				}\u000a\u000a				// draw donut hole\u000a\u000a				drawDonutHole(ctx);\u000a\u000a				ctx.restore();\u000a\u000a				// Draw the labels, returning true if they fit within the plot\u000a\u000a				if (options.series.pie.label.show) {\u000a					return drawLabels();\u000a				} else return true;\u000a\u000a				function drawSlice(angle, color, fill) {\u000a\u000a					if (angle <= 0 || isNaN(angle)) {\u000a						return;\u000a					}\u000a\u000a					if (fill) {\u000a						ctx.fillStyle = color;\u000a					} else {\u000a						ctx.strokeStyle = color;\u000a						ctx.lineJoin = "round";\u000a					}\u000a\u000a					ctx.beginPath();\u000a					if (Math.abs(angle - Math.PI * 2) > 0.000000001) {\u000a						ctx.moveTo(0, 0); // Center of the pie\u000a					}\u000a\u000a					//ctx.arc(0, 0, radius, 0, angle, false); // This doesn't work properly in Opera\u000a					ctx.arc(0, 0, radius,currentAngle, currentAngle + angle / 2, false);\u000a					ctx.arc(0, 0, radius,currentAngle + angle / 2, currentAngle + angle, false);\u000a					ctx.closePath();\u000a					//ctx.rotate(angle); // This doesn't work properly in Opera\u000a					currentAngle += angle;\u000a\u000a					if (fill) {\u000a						ctx.fill();\u000a					} else {\u000a						ctx.stroke();\u000a					}\u000a				}\u000a\u000a				function drawLabels() {\u000a\u000a					var currentAngle = startAngle;\u000a					var radius = options.series.pie.label.radius > 1 ? options.series.pie.label.radius : maxRadius * options.series.pie.label.radius;\u000a\u000a					for (var i = 0; i < slices.length; ++i) {\u000a						if (slices[i].percent >= options.series.pie.label.threshold * 100) {\u000a							if (!drawLabel(slices[i], currentAngle, i)) {\u000a								return false;\u000a							}\u000a						}\u000a						currentAngle += slices[i].angle;\u000a					}\u000a\u000a					return true;\u000a\u000a					function drawLabel(slice, startAngle, index) {\u000a\u000a						if (slice.data[0][1] == 0) {\u000a							return true;\u000a						}\u000a\u000a						// format label text\u000a\u000a						var lf = options.legend.labelFormatter, text, plf = options.series.pie.label.formatter;\u000a\u000a						if (lf) {\u000a							text = lf(slice.label, slice);\u000a						} else {\u000a							text = slice.label;\u000a						}\u000a\u000a						if (plf) {\u000a							text = plf(text, slice);\u000a						}\u000a\u000a						var halfAngle = ((startAngle + slice.angle) + startAngle) / 2;\u000a						var x = centerLeft + Math.round(Math.cos(halfAngle) * radius);\u000a						var y = centerTop + Math.round(Math.sin(halfAngle) * radius) * options.series.pie.tilt;\u000a\u000a						var html = "<span class='pieLabel' id='pieLabel" + index + "' style='position:absolute;top:" + y + "px;left:" + x + "px;'>" + text + "</span>";\u000a						target.append(html);\u000a\u000a						var label = target.children("#pieLabel" + index);\u000a						var labelTop = (y - label.height() / 2);\u000a						var labelLeft = (x - label.width() / 2);\u000a\u000a						label.css("top", labelTop);\u000a						label.css("left", labelLeft);\u000a\u000a						// check to make sure that the label is not outside the canvas\u000a\u000a						if (0 - labelTop > 0 || 0 - labelLeft > 0 || canvasHeight - (labelTop + label.height()) < 0 || canvasWidth - (labelLeft + label.width()) < 0) {\u000a							return false;\u000a						}\u000a\u000a						if (options.series.pie.label.background.opacity != 0) {\u000a\u000a							// put in the transparent background separately to avoid blended labels and label boxes\u000a\u000a							var c = options.series.pie.label.background.color;\u000a\u000a							if (c == null) {\u000a								c = slice.color;\u000a							}\u000a\u000a							var pos = "top:" + labelTop + "px;left:" + labelLeft + "px;";\u000a							$("<div class='pieLabelBackground' style='position:absolute;width:" + label.width() + "px;height:" + label.height() + "px;" + pos + "background-color:" + c + ";'></div>")\u000a								.css("opacity", options.series.pie.label.background.opacity)\u000a								.insertBefore(label);\u000a						}\u000a\u000a						return true;\u000a					} // end individual label function\u000a				} // end drawLabels function\u000a			} // end drawPie function\u000a		} // end draw function\u000a\u000a		// Placed here because it needs to be accessed from multiple locations\u000a\u000a		function drawDonutHole(layer) {\u000a			if (options.series.pie.innerRadius > 0) {\u000a\u000a				// subtract the center\u000a\u000a				layer.save();\u000a				var innerRadius = options.series.pie.innerRadius > 1 ? options.series.pie.innerRadius : maxRadius * options.series.pie.innerRadius;\u000a				layer.globalCompositeOperation = "destination-out"; // this does not work with excanvas, but it will fall back to using the stroke color\u000a				layer.beginPath();\u000a				layer.fillStyle = options.series.pie.stroke.color;\u000a				layer.arc(0, 0, innerRadius, 0, Math.PI * 2, false);\u000a				layer.fill();\u000a				layer.closePath();\u000a				layer.restore();\u000a\u000a				// add inner stroke\u000a\u000a				layer.save();\u000a				layer.beginPath();\u000a				layer.strokeStyle = options.series.pie.stroke.color;\u000a				layer.arc(0, 0, innerRadius, 0, Math.PI * 2, false);\u000a				layer.stroke();\u000a				layer.closePath();\u000a				layer.restore();\u000a\u000a				// TODO: add extra shadow inside hole (with a mask) if the pie is tilted.\u000a			}\u000a		}\u000a\u000a		//-- Additional Interactive related functions --\u000a\u000a		function isPointInPoly(poly, pt) {\u000a			for(var c = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i)\u000a				((poly[i][1] <= pt[1] && pt[1] < poly[j][1]) || (poly[j][1] <= pt[1] && pt[1]< poly[i][1]))\u000a				&& (pt[0] < (poly[j][0] - poly[i][0]) * (pt[1] - poly[i][1]) / (poly[j][1] - poly[i][1]) + poly[i][0])\u000a				&& (c = !c);\u000a			return c;\u000a		}\u000a\u000a		function findNearbySlice(mouseX, mouseY) {\u000a\u000a			var slices = plot.getData(),\u000a				options = plot.getOptions(),\u000a				radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius,\u000a				x, y;\u000a\u000a			for (var i = 0; i < slices.length; ++i) {\u000a\u000a				var s = slices[i];\u000a\u000a				if (s.pie.show) {\u000a\u000a					ctx.save();\u000a					ctx.beginPath();\u000a					ctx.moveTo(0, 0); // Center of the pie\u000a					//ctx.scale(1, options.series.pie.tilt);	// this actually seems to break everything when here.\u000a					ctx.arc(0, 0, radius, s.startAngle, s.startAngle + s.angle / 2, false);\u000a					ctx.arc(0, 0, radius, s.startAngle + s.angle / 2, s.startAngle + s.angle, false);\u000a					ctx.closePath();\u000a					x = mouseX - centerLeft;\u000a					y = mouseY - centerTop;\u000a\u000a					if (ctx.isPointInPath) {\u000a						if (ctx.isPointInPath(mouseX - centerLeft, mouseY - centerTop)) {\u000a							ctx.restore();\u000a							return {\u000a								datapoint: [s.percent, s.data],\u000a								dataIndex: 0,\u000a								series: s,\u000a								seriesIndex: i\u000a							};\u000a						}\u000a					} else {\u000a\u000a						// excanvas for IE doesn;t support isPointInPath, this is a workaround.\u000a\u000a						var p1X = radius * Math.cos(s.startAngle),\u000a							p1Y = radius * Math.sin(s.startAngle),\u000a							p2X = radius * Math.cos(s.startAngle + s.angle / 4),\u000a							p2Y = radius * Math.sin(s.startAngle + s.angle / 4),\u000a							p3X = radius * Math.cos(s.startAngle + s.angle / 2),\u000a							p3Y = radius * Math.sin(s.startAngle + s.angle / 2),\u000a							p4X = radius * Math.cos(s.startAngle + s.angle / 1.5),\u000a							p4Y = radius * Math.sin(s.startAngle + s.angle / 1.5),\u000a							p5X = radius * Math.cos(s.startAngle + s.angle),\u000a							p5Y = radius * Math.sin(s.startAngle + s.angle),\u000a							arrPoly = [[0, 0], [p1X, p1Y], [p2X, p2Y], [p3X, p3Y], [p4X, p4Y], [p5X, p5Y]],\u000a							arrPoint = [x, y];\u000a\u000a						// TODO: perhaps do some mathmatical trickery here with the Y-coordinate to compensate for pie tilt?\u000a\u000a						if (isPointInPoly(arrPoly, arrPoint)) {\u000a							ctx.restore();\u000a							return {\u000a								datapoint: [s.percent, s.data],\u000a								dataIndex: 0,\u000a								series: s,\u000a								seriesIndex: i\u000a							};\u000a						}\u000a					}\u000a\u000a					ctx.restore();\u000a				}\u000a			}\u000a\u000a			return null;\u000a		}\u000a\u000a		function onMouseMove(e) {\u000a			triggerClickHoverEvent("plothover", e);\u000a		}\u000a\u000a		function onClick(e) {\u000a			triggerClickHoverEvent("plotclick", e);\u000a		}\u000a\u000a		// trigger click or hover event (they send the same parameters so we share their code)\u000a\u000a		function triggerClickHoverEvent(eventname, e) {\u000a\u000a			var offset = plot.offset();\u000a			var canvasX = parseInt(e.pageX - offset.left);\u000a			var canvasY =  parseInt(e.pageY - offset.top);\u000a			var item = findNearbySlice(canvasX, canvasY);\u000a\u000a			if (options.grid.autoHighlight) {\u000a\u000a				// clear auto-highlights\u000a\u000a				for (var i = 0; i < highlights.length; ++i) {\u000a					var h = highlights[i];\u000a					if (h.auto == eventname && !(item && h.series == item.series)) {\u000a						unhighlight(h.series);\u000a					}\u000a				}\u000a			}\u000a\u000a			// highlight the slice\u000a\u000a			if (item) {\u000a				highlight(item.series, eventname);\u000a			}\u000a\u000a			// trigger any hover bind events\u000a\u000a			var pos = { pageX: e.pageX, pageY: e.pageY };\u000a			target.trigger(eventname, [pos, item]);\u000a		}\u000a\u000a		function highlight(s, auto) {\u000a			//if (typeof s == "number") {\u000a			//	s = series[s];\u000a			//}\u000a\u000a			var i = indexOfHighlight(s);\u000a\u000a			if (i == -1) {\u000a				highlights.push({ series: s, auto: auto });\u000a				plot.triggerRedrawOverlay();\u000a			} else if (!auto) {\u000a				highlights[i].auto = false;\u000a			}\u000a		}\u000a\u000a		function unhighlight(s) {\u000a			if (s == null) {\u000a				highlights = [];\u000a				plot.triggerRedrawOverlay();\u000a			}\u000a\u000a			//if (typeof s == "number") {\u000a			//	s = series[s];\u000a			//}\u000a\u000a			var i = indexOfHighlight(s);\u000a\u000a			if (i != -1) {\u000a				highlights.splice(i, 1);\u000a				plot.triggerRedrawOverlay();\u000a			}\u000a		}\u000a\u000a		function indexOfHighlight(s) {\u000a			for (var i = 0; i < highlights.length; ++i) {\u000a				var h = highlights[i];\u000a				if (h.series == s)\u000a					return i;\u000a			}\u000a			return -1;\u000a		}\u000a\u000a		function drawOverlay(plot, octx) {\u000a\u000a			var options = plot.getOptions();\u000a\u000a			var radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;\u000a\u000a			octx.save();\u000a			octx.translate(centerLeft, centerTop);\u000a			octx.scale(1, options.series.pie.tilt);\u000a\u000a			for (var i = 0; i < highlights.length; ++i) {\u000a				drawHighlight(highlights[i].series);\u000a			}\u000a\u000a			drawDonutHole(octx);\u000a\u000a			octx.restore();\u000a\u000a			function drawHighlight(series) {\u000a\u000a				if (series.angle <= 0 || isNaN(series.angle)) {\u000a					return;\u000a				}\u000a\u000a				//octx.fillStyle = parseColor(options.series.pie.highlight.color).scale(null, null, null, options.series.pie.highlight.opacity).toString();\u000a				octx.fillStyle = "rgba(255, 255, 255, " + options.series.pie.highlight.opacity + ")"; // this is temporary until we have access to parseColor\u000a				octx.beginPath();\u000a				if (Math.abs(series.angle - Math.PI * 2) > 0.000000001) {\u000a					octx.moveTo(0, 0); // Center of the pie\u000a				}\u000a				octx.arc(0, 0, radius, series.startAngle, series.startAngle + series.angle / 2, false);\u000a				octx.arc(0, 0, radius, series.startAngle + series.angle / 2, series.startAngle + series.angle, false);\u000a				octx.closePath();\u000a				octx.fill();\u000a			}\u000a		}\u000a	} // end init (plugin body)\u000a\u000a	// define pie specific options and their default values\u000a\u000a	var options = {\u000a		series: {\u000a			pie: {\u000a				show: false,\u000a				radius: "auto",	// actual radius of the visible pie (based on full calculated radius if <=1, or hard pixel value)\u000a				innerRadius: 0, /* for donut */\u000a				startAngle: 3/2,\u000a				tilt: 1,\u000a				shadow: {\u000a					left: 5,	// shadow left offset\u000a					top: 15,	// shadow top offset\u000a					alpha: 0.02	// shadow alpha\u000a				},\u000a				offset: {\u000a					top: 0,\u000a					left: "auto"\u000a				},\u000a				stroke: {\u000a					color: "#fff",\u000a					width: 1\u000a				},\u000a				label: {\u000a					show: "auto",\u000a					formatter: function(label, slice) {\u000a						return "<div style='font-size:x-small;text-align:center;padding:2px;color:" + slice.color + ";'>" + label + "<br/>" + Math.round(slice.percent) + "%</div>";\u000a					},	// formatter function\u000a					radius: 1,	// radius at which to place the labels (based on full calculated radius if <=1, or hard pixel value)\u000a					background: {\u000a						color: null,\u000a						opacity: 0\u000a					},\u000a					threshold: 0	// percentage at which to hide the label (i.e. the slice is too narrow)\u000a				},\u000a				combine: {\u000a					threshold: -1,	// percentage at which to combine little slices into one larger slice\u000a					color: null,	// color to give the new slice (auto-generated if null)\u000a					label: "Other"	// label to give the new slice\u000a				},\u000a				highlight: {\u000a					//color: "#fff",		// will add this functionality once parseColor is available\u000a					opacity: 0.5\u000a				}\u000a			}\u000a		}\u000a	};\u000a\u000a	$.plot.plugins.push({\u000a		init: init,\u000a		options: options,\u000a		name: "pie",\u000a		version: "1.1"\u000a	});\u000a\u000a})(jQuery);\u000a\u000a;\u000a
p0
.